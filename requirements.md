# Ход работы

## Исходные данные

Подключаемся к БД и нам доступны две схемы **production** и **analysis**. В первой схеме нам доступны таблицы для работы с данными, а во второй мы будем выполнять задачу, на момент написания  она пустая.

В схеме **production** нам доступны такие таблицы: *orderitems*, *orders*, *orderstatuslog*, 
*products*, *orderstatuses* и *users*.

Связи между таблицами в схеме:
- **products** после *id* с **orderitems** поле *product_id*
- **orderitems** поле *order_id* с **orders** поле *order_id*
- **orders** поле *order_id* с **orderstatuslog** поле *order_id*
- **orderstatuslog** поле *order_id* c *orderstatuses* поле *id*
- **users** после *id* с **orders** поле *user_id*

## План решения

### поле recency

Нам необходим будет индификатор пользователя *user_id*, дата его последнего заказа. Значит из таблицы **orders** нам нужно будет выбрать заказы у которых поле *status_id* будет равен 4 (closed, узнали из таблицы **orderstatuses**).

Получив все заказы которые имеют статус закрытые взять два поля: *user_id*, MAX(*order_ts*). Таким образом мы получим дату последнего заказа каждого клиента. Так как у нас могут быть клиенты которые не сделали ни одного заказа или отменили его, нам нужно будет таблицу **users** объеденить с полученной по полю *id* с полем *user_id*, так мы индификаторы всех клиентов с датами их последнего заказа, если он есть. Затем с помощью функции NTILE ранжируем данные на равных 5 корзинок. Создаем и заполняем таблицу analysis.tmp_rfm_recency. 

### поле frequency

Нам необходим будет индификатор пользователя *user_id*, кол-во его заказов. Повторяем процедуру как в recency, берем закрытые заказы, но берем теперь поля *user_id*, COUNT(*). Тем самым получаем сколько каждый клиент сделал заказов. Также повторяем процедуру с клиентами которые ничего не заказали и заменяем NULL на 0. И также ранжуруем с помощью функции NTILE. Создаем и заполняем таблицу analysis.tmp_rfm_frequency.

### поле monetary_value

Нам необходим будет индификатор пользователя *user_id*, сумма его заказов. Повторяем процедуру как в recency, берем закрытые заказы, но берем теперь поля *user_id*, SUM(payment). Тем самым получаем сколько каждый клиент заплатил. Также повторяем процедуру с клиентами которые ничего не заказали и заменяем NULL на 0. И также ранжуруем с помощью функции NTILE. Создаем таблицу и заполняем analysis.tmp_rfm_monetary_value.

### объединение полей

После того как получили все таблицы, просто объединяем их по полю *user_id* создаем и заполняем  таблицу analysis.dm_rfm_segments.

## Поля для решения

Мы использовали из таблицы **order** поля: *order_id* (номер заказа), *status_id* (статус заказа) и *user_id* (индификатор клиента). Из таблицы **user**: *id* (индификатор клиента).

## Описание файлов

- create_tables_rfm.sql - cодержит скрипт на создание трех таблиц recency, frequency, monetary_value.

- data_quality.md - содержит описание качетсва данных

- datamart_ddl.sql - содержит скрипт на создание таблицы RFM

- datamart_query.sql - содержит скрипт на заполнение данных таблицы RFM

- orders_view.sql - содержит скрипт на создание status_id в таблице orders

- tmp_rfm_frequency.sql - содержит скрипт на заполнение таблицы frequency

- tmp_rfm_monetary_value.sql - содержит скрипт на заполнение таблицы monetary_value

- tmp_rfm_recency.sql - содержит скрипт на заполнение таблицы recency

- views.sql - содержит скрипт переноса из общей схемы в рабочую
